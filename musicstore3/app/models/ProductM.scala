package models

import anorm._
import anorm.SqlParser._
import play.api.Play.current
import play.api.db.DB
import play.api.Logger

case class ProductM(name: String, price: Int, id: Int, img: String)

object ProductM{

	/*val product = {
		get[String]("name") ~
		get[Int]("price") ~
		get[Int]("id") map {
			case name~price~id => ProductM(name, price, id)
		}
	}*/

	//so you don't have to call retrieveAll all the time
	//var listOfProducts = retrieveAll()
	val productsPerPage = 5
	val specialModeKey = "-mode-"

	//GLOBAL VARIABLES: In URL now!
	//var currentSortType = "name"
	//var currentPage = 1


	//*******************************************************
	//MYSQL Communication
	def retrieveAll(): List[ProductM] = DB.withConnection {

		implicit connection =>
		//sql() -> Stream[sqlRow]
		//research what map does
		//val sqlCommand = SQL("SELECT * FROM products")

		val sqlCommand = SQL("SELECT * FROM products ORDER BY name")





		sqlCommand().map ( row =>
			ProductM(row[String]("name"),
				row[Int]("price"),
				row[Int]("id"),
				row[String]("img")
			)
		).toList
	}

	def retrieve(page: Int, sort: String, filter: String): List[ProductM] = DB.withConnection {
		implicit connection =>
		//sql() -> Stream[sqlRow]
		//research what map does
		//val sqlCommand = SQL("SELECT * FROM products")


		//filter is formatted in the following way
		//search-mode-column
		//make search = search
		//make column = column


		

		val column = if (filter.contains(specialModeKey)){
			val separationLocation = filter.indexOfSlice(specialModeKey) + 6
			Logger.debug(filter.slice(separationLocation, filter.length))

			filter.slice(separationLocation, filter.length)
		}else{
			"name"
		}

		val search = if (filter.contains(specialModeKey)){
			val separationLocation = filter.indexOfSlice(specialModeKey)
			val parsed = filter.slice(0, separationLocation)
			//Change wildcards depending on column
			if (column == "name"){
				"%" + parsed + "%" //if contains word, good
			}else {
				parsed
			}
		}else{
			filter
		}

		/*
		val sqlCommand = SQL("SELECT * FROM products WHERE " + column + " LIKE " + 
			"'%" + search + "%'" + " ORDER BY " + sort +
			" LIMIT " + ((page-1)*productsPerPage).toString
			 + " , " + productsPerPage.toString)*/


		//String interpolation
		val sqlStringCreator = s"""
		| SELECT * FROM products WHERE $column 
		| LIKE '$search' ORDER BY $sort LIMIT ${((page-1)*productsPerPage)}, $productsPerPage
		""".stripMargin.filter(c => c != '\n')
		//can't take newlines in SQL

		SQL(sqlStringCreator)().map ( row =>
			ProductM(row[String]("name"),
				row[Int]("price"),
				row[Int]("id"),
				row[String]("img")
			)
		).toList
	}

	def retrieveOne(id: Int): ProductM = DB.withConnection {
		implicit connection =>

		val sqlCommand = SQL("""SELECT * FROM products
			WHERE id = {id}
			""").on("id" -> id)

		val list = sqlCommand().map ( row =>
			ProductM(row[String]("name"),
				row[Int]("price"),
				row[Int]("id"),
				row[String]("img")
			)
		).toList

		val singleProduct = list(0)

		singleProduct
	}


	def insert (product: ProductM) = {
		DB.withConnection { implicit connection =>
			//SQL command for inserting:
			// INSERT INTO table_name VALUES ()
			//{} -> paramaters, filled with .on()

			//ID audomatically generated by SQl
			//No need to add in
			SQL("""INSERT INTO products
				   (name, price, img)
			       VALUES ({name}, {price}, {img})
				""").on(
				"name" -> product.name,
				"price" -> product.price,
				"img" -> product.img
			).executeUpdate() == 1
		//executeUpdate returns rows affected
		//should  be one
		//so should return true
		}
	}

	def update(product: ProductM){
		Logger.info(product.id.toString)

		DB.withConnection { implicit connection =>
			SQL("""UPDATE products
				SET name= {name}, price = {price}, img = {img}
				WHERE id = {id}
				"""
				).on(
				"id" -> product.id,
				"name" -> product.name,
				"price" -> product.price,
				"img" -> product.img
				).executeUpdate() == 1
		}
	}


	def delete (id: Int) {
		DB.withConnection{ implicit connection =>
		SQL("DELETE FROM PRODUCTS WHERE id = {id}").
		on("id" -> id).executeUpdate() == 0
		}
	}

	
	

	def numberOfPages(filter: String)= {
		def numberOfItems = {
			DB.withConnection{ implicit connection =>
				val sqlCommand =SQL("SELECT COUNT(*) FROM products WHERE name LIKE {filter}").on("filter" -> filter)
				//val sqlCommand = SQL("SELECT COUNT(*) FROM products WHERE name LIKE ")

				//sqlCommand().head[Long][].toString
				sqlCommand().map {row=>
					row[Long]("COUNT(*)") //Long is type, COUNT(*) is name in MySQL
				}.toList(0)
			}
		}	
		Logger.debug(numberOfItems.toString)

		(numberOfItems - 1)/productsPerPage + 1
	}


	//SQL() -> Stream[SqlRow]
	//Stream is a lazy list. Part of scala
	//Stream[SqlRow].map maps row to to whatever
	//Stream.head returns first item of Stream

	//***************************************************
	//Helper methods

	def randomID(): Int = { // In efficient
		import scala.util.Random
		val random = new Random();
		val randomInt = random.nextInt.abs
		for ( product <- retrieveAll 
			if (product.id == randomInt)
			){
			//if ID matches, call randomID again
			//Danger of infinite recursive if 
			//all ints are taken
			return randomID()
		}
		//otherwise, just send over randomInt
		randomInt
	}


















	/**
	def retrieveAllSorted(sorttype: String): List[ProductM] = DB.withConnection {

		implicit connection =>
		//sql() -> Stream[sqlRow]
		//research what map does
		val sqlQuery = "SELECT * FROM products ORDER BY " + sorttype

		val sqlCommand = SQL(sqlQuery)

		val list = sqlCommand().map ( row =>
			ProductM(row[String]("name"),
				row[Int]("price"),
				row[Int]("id"),
				row[String]("img")
			)
		).toList

		list
	}
	**/

	


}